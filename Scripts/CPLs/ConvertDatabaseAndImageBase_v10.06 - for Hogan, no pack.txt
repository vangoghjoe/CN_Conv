/*
 * PROGRAM NAME: ConvertDatabaseAndImageBase_v10.06.cpl
 * ------------
 *      Concordance® Programming Language MasterConversionUtility Program Copyright © 2010 LexisNexis,
 *      a division of Reed Elsevier Inc.All rights reserved.
 *      LexisNexis and the Knowledge Burst logo are registered 
 *      trademarks of Reed Elsevier Properties Inc., used under license.  Concordance is a 
 *      registered trademark of LexisNexis, a division of Reed Elsevier Inc.
 *      LexisNexis, 13427 NE 16th ST Suite 200 
 *      Bellevue, WA 98005
 *
 *      Unauthorized distribution, adaptation or use may be 
 *      subject to civil and criminal penalties.
 *     
 *      You may incorporate this program into your own programs 
 *      ONLY if you incorporate the following copyright notice:
 *      Copyright © 20__ YOUR NAME. ALL RIGHTS RESERVED. 
 *      Portions copyright © 1994-2010 LexisNexis, a division of Reed Elsevier, Inc.  
 *      All rights reserved.
 *
 *
 * SYNOPSIS:
 * ---------
 *      This CPL will bulk convert all pre-Concordance v10 databases to Concordance v10
 *      in the parent-level folder(s) that you specify in the log file (see txtFileWithPathsToConvert below).
 *
 *      This CPL will also bulk convert all pre-Concordance v5 imagebases to Concordance Image v5.
 *
 */

int MAX_DATABASES_ALLOWED_OPEN = 16;

/* Change the value of the following variable to match your needs. */
text txtFileWithPathsToConvert = "C:\conversions\db-folders-to-convert.txt";


/****************************************************************
* Name:         Global bit setting variables                    *
*****************************************************************/

int64	VOLUMEBITSv1	=	16383;				/* 0x00003FFF */	/* v1 and v2 are 32 bit but use 64 for consistency */
int64	BOXBITv1		=   16384;				/* 0x00004000 */
int64	FOLDERBITv1		=   32768;				/* 0x00008000 */
int64	DOCBITv1		=   65536;				/* 0x00010000 */
int64	PAGEBITv1		=  131072;				/* 0x00020000 */
int64	PAGEBITSv1		= -131072; 				/* 0xFFFE0000 */

int64	VOLUMEBITSv2	=   131071;				/* 0x0001FFFF */
int64	BOXBITv2		=   131072;				/* 0x00020000 */
int64	FOLDERBITv2		=   262144;				/* 0x00040000 */
int64	DOCBITv2		=   524288;				/* 0x00080000 */
int64	PAGEBITv2		=  1048576;				/* 0x00100000 */
int64	PAGEBITSv2		= -1048576;				/* 0xFFF00000 */

int64	VOLUMEBITSv3	=   536870911;			/* 0x000000001FFFFFFF */
int64	BOXBITv3		=   536870912;			/* 0x0000000020000000 */
int64	FOLDERBITv3		=  1073741824;			/* 0x0000000040000000 */
int64	DOCBITv3		=  2147483648;			/* 0x0000000080000000 */
int64	PAGEBITv3		=  4294967296;			/* 0x0000000100000000 */
int64	PAGEBITSv3		=    16777215*PAGEBITv3;/* 0x00FFFFFF00000000 */
	 /* RESERVED */								/* 0xFF00000000000000 */

int64	VOLUMEBITSv5	=  1073741823;			/* 0x000000003FFFFFFF */
int64	BOXBITv5		=  1073741824;			/* 0x0000000040000000 */
int64	FOLDERBITv5		=  2147483648;			/* 0x0000000080000000 */
int64	PAGEBITv5		=  4294967296;			/* 0x0000000100000000 */
int64	PAGEBITSv5		=    16777215*PAGEBITv5;/* 0x00FFFFFF00000000 */
int64	DOCBITv5		=    16777216*PAGEBITv5;/* 0x0100000000000000 */
	 /* RESERVED */								/* 0xFE00000000000000 */

int64 VOLUMEBITS_SRC;
int64 BOXBIT_SRC;
int64 FOLDERBIT_SRC;
int64 DOCBIT_SRC;
int64 PAGEBITS_SRC;
int64 PAGEBIT_SRC;

int64 VOLUMEBITS_DST;
int64 BOXBIT_DST;
int64 FOLDERBIT_DST;
int64 DOCBIT_DST;
int64 PAGEBITS_DST;
int64 PAGEBIT_DST;


main() {

int    i, fhLog;
char   parentLevelPathsToConvert[256];

   puts(0,0,"Concordance conversion, packing and reindexing daemon");

   /* Open the text file with the parent level folders to convert */
   if ((fhLog = open(txtFileWithPathsToConvert, "r")) <> EOF) {

      /* Read a directory path and then convert, pack and reindex all databases in that directory */
      while (readln(fhLog, parentLevelPathsToConvert) <> EOF)
         ConvertDatabases(parentLevelPathsToConvert);
      
      /* Close log file */
      close(fhLog);
   }

   exit();
}


/****************************************************************
* Name:         ConvertDatabases()                              *
* Synopsis:     Main processing routine for the CPL             *
****************************************************************/
ConvertDatabases(text directoryPath)
{
char szFile[256];
int db, i, fhProgressLog;
text pszLogFile;

/* Name of the log file that tracks the progress. */
pszLogFile = "MyProgessLogFile.txt";

/* Open the progress tracking log file in write mode. */
/* Overwrite the progress tracking log file if it already exists from a previous run. */
fhProgressLog = EOF;
fhProgressLog = open(directoryPath + "\" + pszLogFile, "w+");


   /* Change to the current directory that we are processing. */
   chdir(directoryPath);
   
   for (szFile = findfirst((directoryPath+"*.dcb"), 0); szFile[0]; szFile = findnext()) {

      /* Give the user the opportunity to exit between conversions, if desired. */
      /* NOTE: UNCOMMENT THE CODE IMMEDIATELY BELOW TO ACTIVATE, IF DESIRED. */   
      /* Message("Press [Esc] to quit now.", FALSE);
      i = clock() + 3000;
      while(i > clock()) {
         if (keypress())
            if (getkey() == ESC)
                exit();
      } */

      /* Inform the user that we are converting, packing and reindexing. */

      /* Commented out references to packing the db -- Joe Hudson, LexisNexis, for Hogan 6/19/13 */
      /* Message("Converting, packing and reindexing...", FALSE);  */
      Message("Converting, packing and reindexing...", FALSE);
            
      /* Convert, pack and reindex all databases in the parent folder only */
      if ((db = opendbconvert(szFile)) <> EOF) {
            pszLogFile = "CONVERTED: " + db.database + " [and related files] ON " + dtoc(today());
            /* pack(db); */
            /* pszLogFile = pszLogFile + newline() + "PACKED: " + db.database + " ON " + dtoc(today()); */
            reindex(db);
            pszLogFile = pszLogFile + newline() + "REINDEXED: " + db.database + " ON " + dtoc(today()) + newline();
            closedb(db);
      }
     else
     {
           pszLogFile = pszLogFile + newline() + "NOT CONVERTED: " + directoryPath + szFile;
     }

         if (fhProgressLog <> EOF)
            writeln(fhProgressLog, pszLogFile, len(pszLogFile));
   }
   
     /* Process the imagebases in the parent folder only. */
     Process(directoryPath);
   
} /* ConvertDatabases() */


/********************************************************************
* Name:         Process()                                           *
* Synopsis:     Top-level function to process the imagebase files.  *
*********************************************************************/
Process(text directoryPath)
{
   int   i, j, nDstVersion = 5;
   text  pszModeMessage, pszMask = "*.DIR";

   SetDstBitSettings(nDstVersion);         
   ConvertImagebases(directoryPath, pszMask, nDstVersion);
}

/****************************************************************
* Name:         ConvertImagebases()                             *
* Synopsis:     Recursive function to convert all imagebases.   *
****************************************************************/
ConvertImagebases(text pszPath, pszMask; int nDstVersion)
{
char szFile[256];
text szPath;
int i, length, db;

   /* Convert all imagebases in the current directory. */
   chdir(pszPath);
   for(szFile = findfirst(pszPath+pszMask, 0); szFile[0]; szFile = findnext()) {
      Message("Converting "+pszPath + szFile, FALSE);
      ConvertSingleImagebase(pszPath + szFile, nDstVersion);
   }
   
} /* ConvertImagebases() */


/****************************************************************
* Name:         ConvertSingleImagebase()                        *
* Synopsis:     Converts a single set of imagebase files.       *
****************************************************************/
ConvertSingleImagebase( text pszFile; int nDstVersion )
	{
	text pszFileBase;
	text pszFilePath;
	int i = 0;
	int j = 0;
     int nError = 0;

	/* Get the path and file name root (minus any extension) */
	while( i = match( pszFile, ".", j+1 ) )
		j = i;
	pszFileBase = substr( pszFile, 1, j );

	/* Call conversion routines for the .dir and .vol DBs */
	nError = ConvertSingleDIRImagebase( pszFilePath = pszFileBase + "dir", nDstVersion );
        if (nError == TRUE)
	{
	  ConvertSingleVOLImagebase( pszFilePath = pszFileBase + "vol", nDstVersion );
	} else {
          messageBox("Error in converting DIR file.  VOL file skipped.", "Convert Imagebase Error", MB_OK);
        }
    }

/****************************************************************
* Name:         ConvertSingleDIRImagebase()                     *
* Synopsis:     Converts a single *.DIR imagebase file          *
****************************************************************/
ConvertSingleDIRImagebase(text pszFile; int nDstVersion)
{
   int      btDir,
            btTempDir,
            nError,
            bBoxBreak,
            bFolderBreak,
            bDocBreak,
            nCount,
            nSrcVersion,
            bUpgrade;
   text     pszTempFile;
   
	text	pszKey;
	text	pszUnicodeKey;

   char     szVersion[2];
               
   int64    nSrcData64,
			nDstData64,
			nVolume64,
			nPages64;
 
   /* Set the bit settings and check the version */
   nSrcVersion = SetSrcBitSettings(pszFile);
   puts(0, 0, "Processing DIR file " + pszFile + " from v" + str(nSrcVersion) + " to v" + str(nDstVersion));
   puts(1,0,pad("", 'L',80),MenuColor_);
   nError = 0; 

   if ((nSrcVersion == 3) and (nDstVersion == 4))	/* 3 to 4 does not change bits */
   {
		bUpgrade = TRUE;
		system("copy " + chr(34) + pszFile + chr(34) + " " + chr(34) + pszFile + ".old" + chr(34));        
   }
   else if (nSrcVersion < nDstVersion)
   {
      /* Open the .DIR file */
      if ((btDir = btopen(pszFile)) <> EOF) 
      {      
         /* Create the temp .DIR file */
         if ((btTempDir = btcreate((pszTempFile = pszFile + ".tmp"), FALSE)) <> EOF) 
         {         
            /* Cycle through the original DIR file */
            for (nError = btfirst(btDir, pszKey, nSrcData64); nError == 0; nError = btnext(btDir, pszKey, nSrcData64)) 
            {            
               puts(1,0,pad("Processing record " + str(nCount = nCount + 1), 'L',80),MenuColor_);

               /* Get the various values */
               nVolume64 = nSrcData64 & VOLUMEBITS_SRC;
               nPages64 = (nSrcData64 & PAGEBITS_SRC) / PAGEBIT_SRC;
               if (nSrcData64 & BOXBIT_SRC)
                  bBoxBreak = TRUE;
               else
                  bBoxBreak = FALSE;
               if (nSrcData64 & FOLDERBIT_SRC)
                  bFolderBreak = TRUE;
               else
                  bFolderBreak = FALSE;
               if (nSrcData64 & DOCBIT_SRC)
                  bDocBreak = TRUE;
               else
                  bDocBreak = FALSE;

               /* Convert the values to the new 64-bit value */
               nDstData64 = 0;
               nDstData64 = nVolume64 | (nPages64 * PAGEBIT_DST);
               if (bBoxBreak)
                  nDstData64 = nDstData64 | BOXBIT_DST;
               if (bFolderBreak)
                  nDstData64 = nDstData64 | FOLDERBIT_DST;
               if (bDocBreak)
                  nDstData64 = nDstData64 | DOCBIT_DST;

               /* This data needs to be converted to unicode */
               pszUnicodeKey = pszKey;
               btinsert(btTempDir,pszUnicodeKey,nDstData64);

            }
            
            /* Close the temp .DIR file */
            btclose(btTempDir);
         }
         
         /* Close the .DIR file */
         btclose(btDir);
      }           
      
      if (pszTempFile <> "") 
      {
         /* Unlink the old .DIR file and rename */ 
	 erase(pszFile + ".old"); 
         rename(pszFile, pszFile + ".old");
         nError = rename(pszTempFile, pszFile);

         if (nError == 0)
         {
             bUpgrade = TRUE;     
         } else {
             messageBox("ERROR: Unable to convert " + pszFile + ", file in use.", "Convert Imagebase", MB_OK);
             return(FALSE);
         }
      } 
      
   }

   if (bUpgrade == TRUE)
   {
        szVersion[0] = nDstVersion;
        szVersion[1] = 0;
        SetImagebaseVersion(pszFile, szVersion);
   }
   puts(0,0,pad("", 'L',80),MenuColor_);
   puts(1,0,pad("", 'L',80),MenuColor_);
   return(TRUE);
}

/****************************************************************
* Name:         ConvertSingleVOLImagebase()                     *
* Synopsis:     Converts a single *.VOL imagebase file          *
****************************************************************/
ConvertSingleVOLImagebase(text pszFile; int nDstVersion)
{
   int      btVol,
            btTempVol,
            nError,
            nCount,
            bUpgrade,
            nSrcVersion;
   text     pszTempFile;
   
	text	pszKey;
	text	pszUnicodeKey;

   char     szVersion[2];
               
   int64    nData64;

   /* Set the bit settings and check the version */
   bUpgrade = FALSE;
   nCount = 0;
   nSrcVersion = SetSrcBitSettings(pszFile);
   
   /* Put up a status message */
   puts(0,0, "Processing VOL file " + pszFile + " from v" + str(nSrcVersion) + " to v" + str(nDstVersion));
   puts(1,0,pad("", 'L',80),MenuColor_);

   if ((nSrcVersion == 3) and (nDstVersion == 4))	/* no conversion for < v5 */
   {
      system("copy " + chr(34) + pszFile + chr(34) + " " + chr(34) + pszFile + ".old" + chr(34));        
      bUpgrade = TRUE;
   }
   else if (nSrcVersion < nDstVersion)
   {
      /* Open the .VOL file */
      if ((btVol = btopen(pszFile)) <> EOF) 
      {      
         /* Create the temp .VOL file */
         if ((btTempVol = btcreate((pszTempFile = pszFile + ".tmp"), FALSE)) <> EOF) 
         { 
            bUpgrade = TRUE;
            /* Cycle through the original VOL file */
            for (nError = btfirst(btVol, pszKey, nData64); nError == 0; nError = btnext(btVol, pszKey, nData64)) 
            {            
			puts(1,0,pad("Processing record " + str(nCount = nCount + 1), 'L',80),MenuColor_);
			pszUnicodeKey = pszKey;
			btinsert(btTempVol,pszUnicodeKey,nData64);
            }
            
            /* Close the temp .VOL file */
            btclose(btTempVol);
         }
         
         /* Close the .VOL file */
         btclose(btVol);
        
      } 

      if (pszTempFile <> "") 
      {                             
         /* Unlink the old .DIR file and rename */ 
	 erase(pszFile + ".old"); 
         rename(pszFile, pszFile + ".old");
         nError = rename(pszTempFile, pszFile);

         if (nError == 0)
         {
             bUpgrade = TRUE;     
         } else {
             messageBox("ERROR: Unable to convert " + pszFile + ", file in use.", "Convert Imagebase", MB_OK);
             return(0);
         }
      } 
   } else {
       puts(0,0,pad(pszFile + " is already v" + str(nDstVersion), 'L',80),MenuColor_);
       puts(1,0,pad("", 'L',80),MenuColor_);
       bUpgrade = FALSE;
   }
   if (bUpgrade == TRUE)
   {
      szVersion[0] = nDstVersion;
      szVersion[1] = 0;
      SetImagebaseVersion(pszFile, szVersion);
   }
   puts(0,0,pad("", 'L',80),MenuColor_);
   puts(1,0,pad("", 'L',80),MenuColor_);
   return(1);
}


RGB(char red, grn, blu)
{
   return(((blu & 255) * 65536) | ((grn & 255) * 256) | (red & 255));
}

/****************************************************************
* Name:         Message                                         *
* Synopsis:     Displays error message and waits for key.       *
****************************************************************/
Message(text message; int wait)
{
text screen;
int key;

   cursoroff();
   if (wait)
      screen = save(5,13,8,69);

   box(5,13,8,69, "3D", MenuColor_);
   puts(6,14,pad(message,'C',53),MenuColor_);

   if (wait)  {
      key = getkey();
      restore(5,13,screen);
   }

   return(asc(upper(chr(key))));
}  /* Message() */

/****************************************************************
* Name:         SetSrcBitSettings()                             *
* Synopsis:     Sets the bit settings depending on DIR version. *
****************************************************************/
SetSrcBitSettings(text pszFile)
{
   int      fhDir,
            nVersion = 1;
   char     szVersion[3];
   
   /* Open the file */
   if ((fhDir = open(pszFile, "r")) <> EOF) {
   
      /* Seek to the 24th byte */
      lseek(fhDir, 24, 'B');
      
      /* Read the next 2 bytes */
      read(fhDir, szVersion, 2);

      if (szVersion[0] > 1) {
         nVersion = szVersion[0];
      }
      else {
         if ((szVersion[0] == 1) and (szVersion[1] > 48))
            nVersion = 2;
      }
      
      /* This allows for sub-versions, ie, 4.1 to be detected as 4 */
      if (nVersion > 256) nVersion = nVersion & 255;
	

      /* Set the bit settings */
      switch(nVersion) {
      
         case 1:
            VOLUMEBITS_SRC = VOLUMEBITSv1;
            BOXBIT_SRC     = BOXBITv1;
            FOLDERBIT_SRC  = FOLDERBITv1;
            DOCBIT_SRC     = DOCBITv1;
            PAGEBITS_SRC   = PAGEBITSv1;
            PAGEBIT_SRC    = PAGEBITv1;
            break;
            
         case 2:
            VOLUMEBITS_SRC = VOLUMEBITSv2;
            BOXBIT_SRC     = BOXBITv2;
            FOLDERBIT_SRC  = FOLDERBITv2;
            DOCBIT_SRC     = DOCBITv2;
            PAGEBITS_SRC   = PAGEBITSv2;
            PAGEBIT_SRC    = PAGEBITv2;
            break;
            
         case 3:
            VOLUMEBITS_SRC = VOLUMEBITSv3;
            BOXBIT_SRC     = BOXBITv3;
            FOLDERBIT_SRC  = FOLDERBITv3;
            DOCBIT_SRC     = DOCBITv3;
            PAGEBITS_SRC   = PAGEBITSv3;
            PAGEBIT_SRC    = PAGEBITv3;
            break;
            
        case 4:
            VOLUMEBITS_SRC = VOLUMEBITSv3;
            BOXBIT_SRC     = BOXBITv3;
            FOLDERBIT_SRC  = FOLDERBITv3;
            DOCBIT_SRC     = DOCBITv3;
            PAGEBITS_SRC   = PAGEBITSv3;
            PAGEBIT_SRC    = PAGEBITv3;
            break;
      }
                             
      /* Close the file */
      close(fhDir);
   }
   
   return(nVersion);
}


/****************************************************************
* Name:         SetSrcBitSettings()                             *
* Synopsis:     Sets the bit settings depending on DIR version. *
****************************************************************/
SetDstBitSettings(int nVersion)
{
    switch(nVersion) {
    
        case 3:
        VOLUMEBITS_DST = VOLUMEBITSv3;
        BOXBIT_DST     = BOXBITv3;
        FOLDERBIT_DST  = FOLDERBITv3;
        DOCBIT_DST     = DOCBITv3;
        PAGEBITS_DST   = PAGEBITSv3;
        PAGEBIT_DST    = PAGEBITv3;
        break;
        
        case 4:
        VOLUMEBITS_DST = VOLUMEBITSv3;
        BOXBIT_DST     = BOXBITv3;
        FOLDERBIT_DST  = FOLDERBITv3;
        DOCBIT_DST     = DOCBITv3;
        PAGEBITS_DST   = PAGEBITSv3;
        PAGEBIT_DST    = PAGEBITv3;
        break;
        
		case 5:
        VOLUMEBITS_DST = VOLUMEBITSv5;
        BOXBIT_DST     = BOXBITv5;
        FOLDERBIT_DST  = FOLDERBITv5;
        DOCBIT_DST     = DOCBITv5;
        PAGEBITS_DST   = PAGEBITSv5;
        PAGEBIT_DST    = PAGEBITv5;
        break;
    }
}


/*****************************************************/
/* Function: SetImagebaseVersion()                   */
/* Purpose : Sets the imagebase version              */
/*****************************************************/
SetImagebaseVersion(text pszFile; char szVersion[])
{
   int   fhDir;

   /* Open the file */
   if ((fhDir = open(pszFile, "r+")) <> EOF) {
   
      /* Seek to the 24th byte */
      lseek(fhDir, 24, 'B');
      
      /* Read the next 2 bytes */
      write(fhDir, szVersion, 2);
      
      /* Close the file */
      close(fhDir);      
   }
}

/* Standard dialog button return values. */
int IDOK     = 1;
int IDCANCEL = 2;
int IDABORT  = 3;
int IDRETRY  = 4;
int IDIGNORE = 5;
int IDYES    = 6;
int IDNO     = 7;

/* MessageBox() display options. */
int MB_OK               = 0;
int MB_OKCANCEL         = 1;
int MB_ABORTRETRYIGNORE = 2;
int MB_YESNOCANCEL      = 3;
int MB_YESNO            = 4;
int MB_RETRYCANCEL      = 5;
int MB_TYPEMASK         = 15;

int MB_ICONHAND         = 16;
int MB_ICONQUESTION     = 32;
int MB_ICONEXCLAMATION  = 48;
int MB_ICONASTERISK     = 64;
int MB_ICONMASK         = 240;

int MB_ICONINFORMATION  = MB_ICONASTERISK;
int MB_ICONSTOP         = MB_ICONHAND;

int MB_DEFBUTTON1       = 0;
int MB_DEFBUTTON2       = 256;
int MB_DEFBUTTON3       = 512;
int MB_DEFMASK          = 3840;

int MB_APPLMODAL        = 0;
int MB_SYSTEMMODAL      = 4096;
int MB_TASKMODAL        = 8192;

int MB_NOFOCUS          = 32768;

int OFN_NOVALIDATE	= 256;

char    ESC = 27,
        EOF = -1,
        CR = 13,
        LF = 10,
        CTRLENTER = LF,
        TRUE = 1,
        FALSE = 0;
short   F1 = 15104,
        F2 = 15360,
        F3 = 15616,
        F4 = 15872,
        F5 = 16128,
        F6 = 16384,
        F7 = 16640,
        F8 = 16896,
        F9 = 17152,
        F10 = 17408,
        LEFT = 19200,
        RIGHT = 19712,
        UP = 18432,
        DOWN = 20480,
        PGUP = 18688,
        PGDN = 20736,
        HOME = 18176,
        END = 20224;

